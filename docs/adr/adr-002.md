# ADR 002: Presentation Architecture Pattern

## Metadata
* **Status:** ACCEPTED
* **Date:** 2026-01-28
* **Deciders:** Dmytro Shulha
* **Stakeholders Consulted:** N/A

## 1. Context (The Forces)
With the adoption of Jetpack Compose for the UI, we need a presentation pattern that naturally handles reactive state updates and provides a clear separation between UI and business logic.

* **Business:** Need for a reliable UI that reflects game state accurately.
* **Technological:** Jetpack Compose is state-driven. We need to avoid "state drift" and ensure the UI is a pure function of its state.
* **Project-local:** Ensure developers can easily understand how data flows from the domain layer to the screen.

## 2. Options Considered
* **Option 1: Traditional MVVM (Multiple StateFlows)**
  * **Pros:** Low boilerplate, easy to understand.
  * **Cons:** Harder to synchronize multiple independent states; can lead to inconsistent UI if not careful.
* **Option 2: MVVM with Unidirectional Data Flow (UDF) / MVI-lite**
  * **Pros:** Single source of truth for UI state, predictable state transitions, excellent compatibility with Compose.
  * **Cons:** Requires more boilerplate for State classes and Intents/Events.
* **Option 3: MVP (Model-View-Presenter)**
  * **Pros:** Decouples logic from Android framework.
  * **Cons:** Very verbose with Compose; doesn't leverage Compose's native state management well.

## 3. Decision Outcome
**Chosen Option: MVVM with Unidirectional Data Flow (UDF)**

* **Rationale:** This pattern is the industry standard for Compose. It ensures that the UI only reacts to state changes emitted by the ViewModel, and the ViewModel only modifies state in response to defined Intents or function calls.
* **Implementation Details:**
    * **State:** Defined as immutable Kotlin data classes (e.g., `SudokuGameState`).
    * **ViewModel:** Holds `StateFlow` and exposes it to Composables.
    * **Events/Intents:** UI communicates with ViewModel via function calls or a sealed class (e.g., `SudokuIntent`).

## 4. Consequences
* **{+} Positive:** Improved testability of UI logic by asserting on state transitions.
* **{+} Positive:** Predictable UI behavior; "one-way" data flow prevents complex bugs related to state synchronization.
* **{-} Negative:** Requires creating several data classes for state and events, increasing the number of files/lines of code.
* **{!} Risks/Tech Debt:** Large ViewModels might become "God Objects" if not careful. We should delegate complex logic to Domain UseCases or Handlers (like `SudokuHandler`).

## 5. Validation & Compliance
* Code reviews to ensure Composables are stateless (hoisting state to ViewModel).
* Verify that UI logic is tested in ViewModel unit tests.

## 6. Links & References
* [Official Android Guide: UI Layer](https://developer.android.com/topic/architecture/ui-layer)
* Back to [Log](../adl.md)
