# ADR 009: State Management for Game Logic

## Metadata
* **Status:** ACCEPTED
* **Date:** 2026-01-30
* **Deciders:** Dmytro Shulha
* **Stakeholders Consulted:** N/A

## 1. Context (The Forces)
Sudoku game logic involves complex state transitions (solving cells, adding notes, undo/redo, timer). We need a strategy that keeps this logic manageable and ensures the UI always represents the correct game state.

* **Business:** A bug-free game experience where "Undo" works perfectly and the game state is never corrupted.
* **Technological:** Complex nested data structures (9x9 grid with cells containing values and notes).
* **Project-local:** Logic is shared between the ViewModel and Domain handlers.

## 2. Options Considered
* **Option 1: Centralized Immutable State**
  * **Pros/Cons:** The entire game state is a single immutable data class. "Undo" is as simple as keeping a list of previous states. However, it requires careful deep-copying of the grid to avoid performance issues on older devices.
* **Option 2: Mutable State in ViewModel**
  * **Pros/Cons:** Potentially better performance as only parts of the grid are updated. However, it makes "Undo" extremely complex to implement and can lead to inconsistent UI states if multiple mutations happen concurrently.
* **Option 3: Redux / Store Pattern**
  * **Pros/Cons:** Very formal and structured. However, it adds significant boilerplate for a single-screen game core.

## 3. Decision Outcome
**Chosen Option: Centralized Immutable State**

* **Rationale:** By using a single `SudokuGameState` data class, we ensure that the UI is a pure function of the state. This makes debugging easier and allows for a trivial implementation of the "Undo" feature by storing previous snapshots of the state.
* **Implementation Details:**
    * Use Kotlin `copy()` for state transitions.
    * Business logic is delegated to `SudokuHandler` to keep the ViewModel focused on UI state.

## 4. Consequences
* **{+} Positive:** Extremely reliable "Undo/Redo" functionality.
* **{+} Positive:** State is predictable and easy to test in isolation.
* **{-} Negative:** Frequent allocations of the 9x9 grid during rapid input (mitigated by Kotlin's efficient object allocation and JVM/ART optimizations).

## 5. Validation & Compliance
* Unit tests for `SudokuHandler` to verify state transitions for all game rules.

## 6. Links & References
* [SudokuGameState.kt](../../app/src/main/java/org/dsh/personal/sudoku/domain/entity/SudokuGameState.kt)
* Back to [Log](../adl.md)
